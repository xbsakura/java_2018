      多态-Object类-匿名内部类
同一个方法中，由于参数类型不同导致执行效果各异的现象-->多态

从一定角度来看，封装和继承几乎都是为多态而准备的。
实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。
多态的作用：消除类之间的耦合关系。

多态有两种表现形式：重载和覆盖
①重载（overload），是发生在同一类中。与父类子类、继承毫无关系。
标识一个函数除了函数名外，还有函数的参数（个数和类型）。也就是说，一个类中可以有两个或更多的函数，叫同一个名字而他们的参数不同。
他们之间毫无关系，是不同的函数，可能他们的功能类似，所以才命名一样，增加可读性，仅此而已！
②覆盖(override),是发生在子类中，也就是说必须有继承的情况下才有覆盖发生。
继承一个类，也就有了父类的全部方法，如果哪个方法功能要变，那就把那个函数在子类中重新实现一遍。
这样再调用这个方法的时候，就是执行子类中的过程了。父类中的函数就被覆盖了。
（覆盖的时候函数名和参数要和父类中完全一样,不然你的方法对父类中的方法就不起任何作用，因为两者是两个函数，毫无关系）
java中允许使用父类类型的变量来引用子类类型的对象来实现多态。
instanceof关键字可以判断一个对象是否为某个类（或接口）的实例或者子类实例，用法如下：
对象(或对象引用变量) instanceof 类(或接口)

Object类
JDK中提供了Object类，它是所有类的父类.

匿名内部类-->实现接口的另外一种方法
格式:new 父类(参数列表) 或 父接口(){实现部分}；
如下所示：animalShout(new Animal(){})
